---
title: Usage
description: usage
slug: getting-started/usage
---

import { Aside, Tabs, TabItem} from "@astrojs/starlight/components";


## Importing the `TranslateModule`

To use ngx-translate in your project, import `TranslateModule.forRoot()` in the
root NgModule of your application.

The `forRoot()` static method provides and configures services simultaneously.
Ensure it's only called within the root module of your application, commonly
referred to as `AppModule`.

This method lets you configure the `TranslateModule` by specifying a loader,
a parser, and/or a missing translations handler. Additionally, you can set the
default language using `defaultLanguage`.

See the section [Translate Module API](/reference/translate-module-api) for details.

```ts {3,8-10}
import {BrowserModule} from '@angular/platform-browser';
import {NgModule} from '@angular/core';
import {TranslateModule} from '@ngx-translate/core';

@NgModule({
    imports: [
        BrowserModule,
        TranslateModule.forRoot({
            defaultLanguage: 'en'
        })
    ],
    bootstrap: [AppComponent]
})
export class AppModule { }
```



## Usage with SharedModules

If you use a [`SharedModule`](https://angular.io/guide/sharing-ngmodules) that you import in multiple other feature modules,
you can export the `TranslateModule` to make sure you don't have to import it in every module.

```ts
@NgModule({
    exports: [
        CommonModule,
        TranslateModule
    ]
})
export class SharedModule { }
```

<Aside type="caution">

Note: Never call a `forRoot` static method in the `SharedModule`. You might end up with different instances of the service in your injector tree. But you can use `forChild` if necessary.

</Aside>

## Lazy loaded modules

When you lazy load a module, you should use the `forChild` static method to import the `TranslateModule`.

Since lazy loaded modules use a different injector from the rest of your application, you can configure them separately with a different loader/compiler/parser/missing translations handler.

To make a child module extend translations from parent modules use `extend: true`. This will cause the service to also
use translations from its parent module.

You can also isolate the service by using `isolate: true`. In which case the service is a completely isolated instance (for translations, current lang, events, ...).
Otherwise, by default, it will share its data with other instances of the service (but you can still use a different loader/compiler/parser/handler even if you don't isolate the service).

```ts
@NgModule({
    imports: [
        TranslateModule.forChild({
            loader: {provide: TranslateLoader, useClass: CustomLoader},
            compiler: {provide: TranslateCompiler, useClass: CustomCompiler},
            parser: {provide: TranslateParser, useClass: CustomParser},
            missingTranslationHandler: {provide: MissingTranslationHandler, useClass: CustomHandler},
            isolate: true
        })
    ]
})
export class LazyLoadedModule { }
```

## Loading language files dynamically

By default, there is no loader available. You can add translations manually using `setTranslation` but it is better to use a loader.
You can write your own loader, or import an existing one.

Ngx-translate comes with `TranslateHttpLoader` which loads translation files using `HttpClient`.
To use it, you need to install the http-loader package from @ngx-translate:

<Tabs syncKey="packetmanager">
    <TabItem label="npm">
```bash
npm install @ngx-translate/http-loader --save
```
    </TabItem>
    <TabItem label="yarn">
```bash
yarn add @ngx-translate/http-loader
```
    </TabItem>
</Tabs>



Once you've decided which loader to use, you have to set up the `TranslateModule` to use it.

Here is how you would use the `TranslateHttpLoader` to load
translations from `"/assets/i18n/[lang].json"`. `[lang]` is the lang that you're using, for english it could be `en`.

You have to create the translate loader inside a factory method if you want to
use [AoT compilation](https://angular.dev/tools/cli/aot-compiler) or [Ionic](http://ionic.io/).

```ts {3-5,8-10,16-23}
import {NgModule} from '@angular/core';
import {BrowserModule} from '@angular/platform-browser';
import {HttpClientModule, HttpClient} from '@angular/common/http';
import {TranslateModule, TranslateLoader} from '@ngx-translate/core';
import {TranslateHttpLoader} from '@ngx-translate/http-loader';
import {AppComponent} from './app';

export function HttpLoaderFactory(http: HttpClient) {
    return new TranslateHttpLoader(http, './assets/i18n/', '.json');
}

@NgModule({
    imports: [
        BrowserModule,
        HttpClientModule,
        TranslateModule.forRoot({
            loader: {
                provide: TranslateLoader,
                useFactory: HttpLoaderFactory,
                deps: [HttpClient]
            },
            defaultLanguage: 'en'
        })
    ],
    bootstrap: [AppComponent]
})
export class AppModule { }
```


## Initialize the `TranslateService` for your application


```ts {2,7,11-16}
import {Component} from '@angular/core';
import {TranslateService} from '@ngx-translate/core';

@Component({
    selector: 'app',
    template: `
        <div>{{ 'app.hello' | translate:param }}</div>
    `
})
export class AppComponent {
    param = {value: 'world'};

    constructor(translate: TranslateService) {
        translate.setDefaultLang('en');
        translate.use('en');
    }
}
```

[`setDefaultLang()`](/reference/translate-service-api/#setdefaultlang) sets the default language. The default language is used
as a fall-back if no translation is found in the currently selected language.
You can also do this at application startup using the `TranslateModule.forRoot({defaultLanguage:'en'})`.

[`use()`](/reference/translate-service-api/#use) sets the current language for the application. If the selected language is not yet
loaded, the loader is invoked to retrieve the file.


## Define the translations

Once you've imported the `TranslateModule`, you can put your translations
in a JSON file that will be imported with the `TranslateHttpLoader`.
The following translations should be stored in `./assets/i18n/en.json`.

```json
{
    "app.hello": "hello {{value}}"
}
```

You can also define your translations manually with [`setTranslation()`](/reference/translate-service-api/#settranslation).

```ts
translate.setTranslation('en', {
    "app.hello": 'hello {{value}}'
});
```

You can also use nested JSON objects &mdash; this allows you to create more structured translation files and
provide some more context for the translators.

```json
{
    "app": {
        "hello": "hello {{value}}"
    }
}
```

You can then access the value by using the dot notation, in this case `app.hello`.

We highly recommend using [BabelEdit](https://www.codeandweb.com/babeledit) to manage your translations. It allows you to
edit all JSON files at once, keeping them consistent. Features like PreTranslate allow you a
fast preview of your application in other languages.


## Work with translations in your components

You can either use the `TranslateService`, the `TranslatePipe` or the `TranslateDirective` to get your translation values.

## Using translations in a component

With the **service**, it looks like this:

```ts
translate.get('app.hello', {value: 'world'}).subscribe((res: string) => {
    console.log(res);
    //=> 'hello world'
});
```

You might ask yourself, why [`get()`](/reference/translate-service-api/#get) is using a subscription to receive the translation.
This is because your language file might not be loaded when the [get()](/reference/translate-service-api/#get) function is called.
The update is triggered when the loading is complete.

You can also use [`stream()`](/reference/translate-service-api/#stream) which is similar to `get()` but also fires when the language is changed.

There is also [`instant()`](/reference/translate-service-api/#instant) &mdash; a synchronous method that returns the translation value
immediately. This only works if the translation file is already loaded &mdash; or the translations
are set using  [`setTranslation()`]/reference/translate-service-api/#settranslation).

## Using translations in templates (TranslatePipe, TranslateDirective)

This is how you do it with the **pipe**:

```html
<div>{{ 'app.hello' | translate:param }}</div>
```

And in your component define `param` like this:
```ts
param = {value: 'world'};
```

You can construct the translation keys dynamically by using simple string concatenation inside the template:

```html
<ul *ngFor="let language of languages">
  <li>{{ 'languages.' + language | translate }}</li>
</ul>
```

Where `languages` is an array member of your component:

```ts
languages = ['en', 'fr', 'de'];
```

You language file would look like this;
```json
{
    'languages': {
        'en': 'English',
        'fr': 'French',
        'de': 'German'
    }
}
```

You can also use the output of the built-in pipes `uppercase` and `lowercase` in order to guarantee
that your dynamically generated translation keys are either all uppercase or all lowercase. For example:

```html
<p>{{ 'roles.' + role | lowercase | translate }}</p>
```

```ts
role = 'ADMIN';
```

will match the following translation:
```json
{
  "roles": {
    "admin": "Administrator"
  }
}
```

<Aside type="tip">

A plugin called **ngx-translate-extract** can help you keeping your source code and translation files in
sync: It extracts the translation IDs from your source code. This does of course not work with
dynamically created IDs like the one above.

</Aside>

This is how you use the **directive**:

```html
<div [translate]="'app.hello'" [translateParams]="{value: 'world'}"></div>
```

Or even simpler using the content of your element as a key:
```html
<div translate [translateParams]="{value: 'world'}">HELLO</div>
```

I recommend not use the **pipe** instead of the directive because both variants of the directive have issues.
The one without a value causes warnings in some IDEs, the first one does currently not properly work
with the message compiler plugin.

## Using HTML tags in your translations

You can easily use raw HTML tags within your translations.

```json
{
    "app.hello": "Welcome to my Angular application!<br><strong>This is an amazing app which uses the latest technologies!</strong>"
}
```

To render them, simply use the `innerHTML` attribute with the pipe on any element.

```html
<div [innerHTML]="'app.hello' | translate"></div>
```

`[innerHTML]` should be safe to use because it uses Angular's `DomSanitizer` to filter potentially harmful tags like
`<script>` or `<style>`.
